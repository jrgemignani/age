/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
--
-- agtype_access_operator regression tests
--
-- Tests for property access optimization:
-- 1. Zero-copy key extraction
-- 2. Direct properties offset access for vertex/edge
--
--
-- Load extension and set path
--
LOAD 'age';
SET search_path TO ag_catalog;
--
-- Create test graph
--
SELECT create_graph('agtype_access_test');
NOTICE:  graph "agtype_access_test" has been created
 create_graph 
--------------
 
(1 row)

--
-- Create test data with various property types
--
SELECT * FROM cypher('agtype_access_test', $$
    CREATE (n:Person {
        name: 'Alice',
        age: 30,
        height: 5.8,
        active: true,
        tags: ['engineer', 'developer'],
        address: {city: 'Seattle', zip: '98101'},
        metadata: null
    })
    RETURN n
$$) AS (v agtype);
                                                                                                        v                                                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 844424930131969, "label": "Person", "properties": {"age": 30, "name": "Alice", "tags": ["engineer", "developer"], "active": true, "height": 5.8, "address": {"zip": "98101", "city": "Seattle"}}}::vertex
(1 row)

SELECT * FROM cypher('agtype_access_test', $$
    CREATE (n:Person {
        name: 'Bob',
        age: 25,
        scores: [85, 90, 78],
        nested: {level1: {level2: {level3: 'deep'}}}
    })
    RETURN n
$$) AS (v agtype);
                                                                                     v                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 844424930131970, "label": "Person", "properties": {"age": 25, "name": "Bob", "nested": {"level1": {"level2": {"level3": "deep"}}}, "scores": [85, 90, 78]}}::vertex
(1 row)

-- Create edges with properties
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (a:Person {name: 'Alice'}), (b:Person {name: 'Bob'})
    CREATE (a)-[e:KNOWS {since: 2020, weight: 0.95, notes: 'colleagues'}]->(b)
    RETURN e
$$) AS (e agtype);
                                                                                       e                                                                                        
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 1125899906842625, "label": "KNOWS", "end_id": 844424930131970, "start_id": 844424930131969, "properties": {"notes": "colleagues", "since": 2020, "weight": 0.95}}::edge
(1 row)

--
-- Test 1: Basic property access (string, integer, float, boolean)
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN n.name, n.age, n.height, n.active
$$) AS (name agtype, age agtype, height agtype, active agtype);
  name   | age | height | active 
---------+-----+--------+--------
 "Alice" | 30  | 5.8    | true
(1 row)

--
-- Test 2: Null property access
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN n.metadata, n.nonexistent
$$) AS (metadata agtype, nonexistent agtype);
 metadata | nonexistent 
----------+-------------
          | 
(1 row)

--
-- Test 3: Array property access
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN n.tags, n.tags[0], n.tags[1]
$$) AS (tags agtype, tag0 agtype, tag1 agtype);
           tags            |    tag0    |    tag1     
---------------------------+------------+-------------
 ["engineer", "developer"] | "engineer" | "developer"
(1 row)

-- Negative array index
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Bob'})
    RETURN n.scores[-1], n.scores[-2]
$$) AS (last agtype, second_last agtype);
 last | second_last 
------+-------------
 78   | 90
(1 row)

--
-- Test 4: Nested object property access
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN n.address, n.address.city, n.address.zip
$$) AS (address agtype, city agtype, zip agtype);
               address               |   city    |   zip   
-------------------------------------+-----------+---------
 {"zip": "98101", "city": "Seattle"} | "Seattle" | "98101"
(1 row)

-- Deep nesting
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Bob'})
    RETURN n.nested.level1.level2.level3
$$) AS (deep_value agtype);
 deep_value 
------------
 "deep"
(1 row)

--
-- Test 5: Edge property access
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH ()-[e:KNOWS]->()
    RETURN e.since, e.weight, e.notes
$$) AS (since agtype, weight agtype, notes agtype);
 since | weight |    notes     
-------+--------+--------------
 2020  | 0.95   | "colleagues"
(1 row)

--
-- Test 6: Multiple property access from same vertex
-- (Tests optimization for repeated access patterns)
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person)
    RETURN n.name, n.age, n.name, n.age
$$) AS (name1 agtype, age1 agtype, name2 agtype, age2 agtype);
  name1  | age1 |  name2  | age2 
---------+------+---------+------
 "Alice" | 30   | "Alice" | 30
 "Bob"   | 25   | "Bob"   | 25
(2 rows)

--
-- Test 7: Property access in WHERE clause
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person)
    WHERE n.age > 25
    RETURN n.name
$$) AS (name agtype);
  name   
---------
 "Alice"
(1 row)

--
-- Test 8: Property access with ORDER BY
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person)
    RETURN n.name, n.age
    ORDER BY n.age DESC
$$) AS (name agtype, age agtype);
  name   | age 
---------+-----
 "Alice" | 30
 "Bob"   | 25
(2 rows)

--
-- Test 9: Property access in aggregations
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person)
    RETURN count(n.age), sum(n.age), avg(n.age)
$$) AS (cnt agtype, total agtype, average agtype);
 cnt | total | average 
-----+-------+---------
 2   | 55    | 27.5
(1 row)

--
-- Test 10: Property access with CASE expressions
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person)
    RETURN n.name,
           CASE WHEN n.age > 25 THEN 'senior' ELSE 'junior' END as category
$$) AS (name agtype, category agtype);
  name   | category 
---------+----------
 "Alice" | "senior"
 "Bob"   | "junior"
(2 rows)

--
-- Test 11: Property access on computed/intermediate values
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    WITH n.address as addr
    RETURN addr.city, addr.zip
$$) AS (city agtype, zip agtype);
   city    |   zip   
-----------+---------
 "Seattle" | "98101"
(1 row)

--
-- Test 12: Mixed array index and property access
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN n.tags[0]
$$) AS (first_tag agtype);
 first_tag  
------------
 "engineer"
(1 row)

--
-- Test 13: Reserved field access (id, label)
-- Note: These access the vertex/edge special fields
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN id(n), label(n)
$$) AS (id agtype, lbl agtype);
       id        |   lbl    
-----------------+----------
 844424930131969 | "Person"
(1 row)

SELECT * FROM cypher('agtype_access_test', $$
    MATCH ()-[e:KNOWS]->()
    RETURN id(e), label(e), start_id(e), end_id(e)
$$) AS (id agtype, lbl agtype, start_id agtype, end_id agtype);
        id        |   lbl   |    start_id     |     end_id      
------------------+---------+-----------------+-----------------
 1125899906842625 | "KNOWS" | 844424930131969 | 844424930131970
(1 row)

--
-- Test 14: Property access with NULL container (should return NULL)
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN n.nonexistent.nested.deep
$$) AS (result agtype);
 result 
--------
 
(1 row)

--
-- Test 15: Array index out of bounds (should return NULL)
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person {name: 'Alice'})
    RETURN n.tags[100], n.tags[-100]
$$) AS (pos_oob agtype, neg_oob agtype);
 pos_oob | neg_oob 
---------+---------
         | 
(1 row)

--
-- Test 16: Direct SQL access operator tests
-- Tests the agtype_access_operator function directly
--
-- Simple object access
SELECT agtype_access_operator('{"a": 1, "b": 2}'::agtype, '"a"'::agtype);
 agtype_access_operator 
------------------------
 1
(1 row)

SELECT agtype_access_operator('{"a": 1, "b": 2}'::agtype, '"b"'::agtype);
 agtype_access_operator 
------------------------
 2
(1 row)

SELECT agtype_access_operator('{"a": 1, "b": 2}'::agtype, '"c"'::agtype);
 agtype_access_operator 
------------------------
 
(1 row)

-- Simple array access
SELECT agtype_access_operator('[1, 2, 3]'::agtype, '0'::agtype);
 agtype_access_operator 
------------------------
 1
(1 row)

SELECT agtype_access_operator('[1, 2, 3]'::agtype, '1'::agtype);
 agtype_access_operator 
------------------------
 2
(1 row)

SELECT agtype_access_operator('[1, 2, 3]'::agtype, '2'::agtype);
 agtype_access_operator 
------------------------
 3
(1 row)

SELECT agtype_access_operator('[1, 2, 3]'::agtype, '-1'::agtype);
 agtype_access_operator 
------------------------
 3
(1 row)

-- Nested access
SELECT agtype_access_operator('{"a": {"b": {"c": 42}}}'::agtype, '"a"'::agtype, '"b"'::agtype, '"c"'::agtype);
 agtype_access_operator 
------------------------
 42
(1 row)

-- Mixed object and array access
SELECT agtype_access_operator('{"arr": [1, 2, 3]}'::agtype, '"arr"'::agtype, '1'::agtype);
 agtype_access_operator 
------------------------
 2
(1 row)

SELECT agtype_access_operator('[{"x": 10}, {"x": 20}]'::agtype, '0'::agtype, '"x"'::agtype);
 agtype_access_operator 
------------------------
 10
(1 row)

-- NULL handling
SELECT agtype_access_operator('{"a": null}'::agtype, '"a"'::agtype);
 agtype_access_operator 
------------------------
 
(1 row)

--
-- Test 17: Property access with special characters in keys
--
SELECT * FROM cypher('agtype_access_test', $$
    CREATE (n:Special {`special-key`: 'value1', `key.with.dots`: 'value2'})
    RETURN n.`special-key`, n.`key.with.dots`
$$) AS (v1 agtype, v2 agtype);
    v1    |    v2    
----------+----------
 "value1" | "value2"
(1 row)

--
-- Test 18: Large object property access (many properties)
--
SELECT * FROM cypher('agtype_access_test', $$
    CREATE (n:Large {
        p1: 1, p2: 2, p3: 3, p4: 4, p5: 5,
        p6: 6, p7: 7, p8: 8, p9: 9, p10: 10,
        p11: 11, p12: 12, p13: 13, p14: 14, p15: 15,
        p16: 16, p17: 17, p18: 18, p19: 19, p20: 20
    })
    RETURN n.p1, n.p10, n.p20
$$) AS (p1 agtype, p10 agtype, p20 agtype);
 p1 | p10 | p20 
----+-----+-----
 1  | 10  | 20
(1 row)

--
-- Test 19: Property access with unicode keys
--
SELECT * FROM cypher('agtype_access_test', $$
    CREATE (n:Unicode {ÂêçÂâç: 'test', donn√©es: 42, emojiüöÄ: 'rocket'})
    RETURN n.ÂêçÂâç, n.donn√©es
$$) AS (name_jp agtype, data_fr agtype);
 name_jp | data_fr 
---------+---------
 "test"  | 42
(1 row)

--
-- Test 20: Property access after collection operations
--
SELECT * FROM cypher('agtype_access_test', $$
    MATCH (n:Person)
    WITH collect(n) as people
    RETURN people[0].name, people[1].name
$$) AS (first agtype, second agtype);
  first  | second 
---------+--------
 "Alice" | "Bob"
(1 row)

--
-- Test 21: Empty object/array property access
--
SELECT agtype_access_operator('{}'::agtype, '"a"'::agtype);
 agtype_access_operator 
------------------------
 
(1 row)

SELECT agtype_access_operator('[]'::agtype, '0'::agtype);
 agtype_access_operator 
------------------------
 
(1 row)

--
-- Test 22: Numeric string keys in objects
--
SELECT agtype_access_operator('{"0": "zero", "1": "one"}'::agtype, '"0"'::agtype);
 agtype_access_operator 
------------------------
 "zero"
(1 row)

SELECT agtype_access_operator('{"0": "zero", "1": "one"}'::agtype, '"1"'::agtype);
 agtype_access_operator 
------------------------
 "one"
(1 row)

--
-- Test 23: Boolean as array index (should error)
--
-- This should fail with an appropriate error
SELECT * FROM cypher('agtype_access_test', $$
    RETURN [1,2,3][true]
$$) AS (result agtype);
ERROR:  array index must resolve to an integer value
--
-- Test 24: Float as array index (should error)
--
-- This should fail
SELECT * FROM cypher('agtype_access_test', $$
    RETURN [1,2,3][1.5]
$$) AS (result agtype);
ERROR:  array index must resolve to an integer value
--
-- Test 25: Integer as object key (should error for map access)
--
SELECT * FROM cypher('agtype_access_test', $$
    RETURN {a: 1}[0]
$$) AS (result agtype);
ERROR:  AGTV_INTEGER is not a valid key type
--
-- Test 26: Stress test - deep nesting
--
SELECT agtype_access_operator(
    '{"l1": {"l2": {"l3": {"l4": {"l5": "deep"}}}}}'::agtype,
    '"l1"'::agtype, '"l2"'::agtype, '"l3"'::agtype, '"l4"'::agtype, '"l5"'::agtype
);
 agtype_access_operator 
------------------------
 "deep"
(1 row)

--
-- Cleanup
--
SELECT drop_graph('agtype_access_test', true);
NOTICE:  drop cascades to 7 other objects
DETAIL:  drop cascades to table agtype_access_test._ag_label_vertex
drop cascades to table agtype_access_test._ag_label_edge
drop cascades to table agtype_access_test."Person"
drop cascades to table agtype_access_test."KNOWS"
drop cascades to table agtype_access_test."Special"
drop cascades to table agtype_access_test."Large"
drop cascades to table agtype_access_test."Unicode"
NOTICE:  graph "agtype_access_test" has been dropped
 drop_graph 
------------
 
(1 row)

